# FORGE APEX OUTPUT EXAMPLE: Link Health Dashboard

Detta är ett exempel på vad `FORGE APEX` levererar.
Komplett APEX-plan redo att köras genom manifestorn.

---

## Run with

```bash
cd the_apex
python bootstrap.py --blueprint=config/link_health_blueprint.yaml --jobs=config/link_health_jobs.yaml
```

---

## config/link_health_blueprint.yaml

```yaml
# ═══════════════════════════════════════════════════════════════════════════════
# APEX BLUEPRINT: Link Health Dashboard
# Generated by APEX-FORGE
# ═══════════════════════════════════════════════════════════════════════════════

project:
  name: "Link Health Dashboard"
  domain: "seo_analytics"
  version: "1.0.0"
  description: "Real-time link health monitoring combining density and anchor risk analysis"

tech_stack:
  backend: "fastapi"
  frontend: "htmx"  # Lightweight, no build step
  db: "sqlite"  # Simple, embeddable
  cache: "memory"  # In-process for MVP
  infra: "docker"

apex_integration:
  runtime_motor: true
  patterns_used:
    - "EXPANSION"
    - "VALIDATION"
    - "COMPRESSION"
  quality_floor: 0.85
  locations:
    - "backend/core/apex_runtime"

module_slots:
  - id: "http_gateway"
    type: "api_layer"
    description: "FastAPI HTTP interface"
    
  - id: "analysis_engine"
    type: "domain_service"
    description: "Core link analysis services"
    
  - id: "dashboard_ui"
    type: "frontend"
    description: "HTMX-powered dashboard"
    
  - id: "data_store"
    type: "persistence"
    description: "Analysis history storage"

modules:
  - module_id: "core.http_api.fastapi"
    slot: "http_gateway"
    config:
      base_path: "/api"
      cors_origins: ["*"]
      docs_enabled: true

  - module_id: "core.apex_runtime"
    slot: "http_gateway"
    config:
      enable_motor: true

  - module_id: "feature.seo.link_health_analyzer"
    slot: "analysis_engine"
    config:
      density_threshold: 3.0
      anchor_diversity_min: 0.7
      cache_ttl_seconds: 3600

  - module_id: "feature.seo.link_health_dashboard"
    slot: "dashboard_ui"
    config:
      theme: "dark"
      refresh_interval: 30

  - module_id: "core.sqlite_store"
    slot: "data_store"
    config:
      db_path: "data/analysis.db"
      auto_migrate: true

pipelines:
  - id: "link_health_analysis_pipeline"
    module: "feature.seo.link_health_analyzer"
    trigger: "http"
    quality_floor: 0.90
    
  - id: "batch_analysis_pipeline"
    module: "feature.seo.link_health_analyzer"
    trigger: "schedule"
    schedule: "0 */6 * * *"  # Every 6 hours
    quality_floor: 0.85
```

---

## config/link_health_jobs.yaml

```yaml
# ═══════════════════════════════════════════════════════════════════════════════
# APEX JOBS: Link Health Dashboard
# ═══════════════════════════════════════════════════════════════════════════════

jobs:
  - id: "link_health_analyzer_v1"
    type: "feature"
    module: "feature.seo.link_health_analyzer"
    description: |
      Complete link health analysis service that:
      - Fetches and parses HTML from target URLs
      - Calculates link density metrics (internal/external ratio, links per word)
      - Analyzes anchor text patterns for SEO risk
      - Generates composite health score (0-100)
      - Provides actionable recommendations
    constraints:
      - "Must handle failed URL fetches gracefully"
      - "Analysis must complete within 30 seconds per URL"
      - "Must support batch analysis of up to 100 URLs"
      - "All metrics must be explainable (show calculation)"
    success_criteria:
      - "Health grade correlates with manual SEO audit (>80% agreement)"
      - "Zero false positives on compliant pages"
      - "Recommendations are actionable and specific"
    apex_patterns:
      generation: "EXPANSION"
      validation: "VALIDATION"
      refinement: "COMPRESSION"

  - id: "link_health_dashboard_v1"
    type: "feature"
    module: "feature.seo.link_health_dashboard"
    description: |
      HTMX-powered dashboard that:
      - Shows real-time analysis results
      - Displays historical trends per domain
      - Provides drill-down into specific issues
      - Exports reports as PDF/CSV
    constraints:
      - "No JavaScript build step (HTMX + Alpine.js only)"
      - "Must work without JavaScript (progressive enhancement)"
      - "Mobile responsive"
      - "Load time < 2 seconds"
    success_criteria:
      - "Users can analyze a URL in under 3 clicks"
      - "Dashboard updates in real-time during analysis"
      - "Historical data visualized clearly"
    apex_patterns:
      generation: "EXPANSION"
      validation: "VALIDATION"

  - id: "sqlite_store_v1"
    type: "core"
    module: "core.sqlite_store"
    description: |
      Lightweight SQLite storage for:
      - Analysis results history
      - Domain tracking
      - User preferences
    constraints:
      - "Single file database"
      - "Auto-migration on startup"
      - "Async compatible (aiosqlite)"
    success_criteria:
      - "Query latency < 50ms for recent results"
      - "Handles 10,000+ stored analyses"
```

---

## modules/feature.seo.link_health_analyzer/module_manifest.yaml

```yaml
# ═══════════════════════════════════════════════════════════════════════════════
# MODULE MANIFEST: Link Health Analyzer
# ═══════════════════════════════════════════════════════════════════════════════

module_id: "feature.seo.link_health_analyzer"
module_type: "domain_service"
version: "1.0.0"

depends_on:
  - "core.http_api.fastapi"
  - "core.apex_runtime"
  - "core.sqlite_store"

capabilities_provided:
  - "link_density_analysis"
  - "anchor_text_analysis"
  - "health_scoring"
  - "batch_analysis"

capabilities_required:
  - "http_routing"
  - "async_http_client"
  - "html_parsing"
  - "data_persistence"

mount_points:
  - "backend/services/link_health"
  - "backend/api/link_health"

templates:
  - id: "models"
    input_type: "schema"
    output_path: "backend/services/link_health/models.py"
    apex_pattern: "EXPANSION"
    quality_function: "schema_completeness"

  - id: "density_service"
    input_type: "job_spec"
    output_path: "backend/services/link_health/density.py"
    apex_pattern: "EXPANSION"
    quality_function: "code_coverage"

  - id: "anchor_service"
    input_type: "job_spec"
    output_path: "backend/services/link_health/anchors.py"
    apex_pattern: "EXPANSION"
    quality_function: "code_coverage"

  - id: "health_scorer"
    input_type: "job_spec"
    output_path: "backend/services/link_health/scorer.py"
    apex_pattern: "EXPANSION"
    quality_function: "algorithm_correctness"

  - id: "api_router"
    input_type: "blueprint_and_job"
    output_path: "backend/api/link_health/routes.py"
    apex_pattern: "EXPANSION"
    quality_function: "api_completeness"

  - id: "pipeline"
    input_type: "blueprint_and_job"
    output_path: "pipelines/link_health_pipeline.yaml"
    apex_pattern: "CONSTRUCTION"
    quality_function: "pipeline_validity"

tests:
  - id: "test_density"
    template: "test_density.py.j2"
    output_path: "tests/test_link_health_density.py"
    
  - id: "test_anchors"
    template: "test_anchors.py.j2"
    output_path: "tests/test_link_health_anchors.py"
    
  - id: "test_api"
    template: "test_api.py.j2"
    output_path: "tests/test_link_health_api.py"
```

---

## modules/feature.seo.link_health_analyzer/templates/models.py.j2

```jinja2
{# ═══════════════════════════════════════════════════════════════════════════════
   TEMPLATE: Link Health Models
   Generated by APEX Manifestor
═══════════════════════════════════════════════════════════════════════════════ #}
"""
Link Health Analysis Data Models.

Project: {{ project.name }}
Module: {{ module.module_id }}
Generated: {{ generation_timestamp }}
"""
from datetime import datetime
from enum import Enum
from typing import Optional

from pydantic import BaseModel, Field, HttpUrl


class HealthGrade(str, Enum):
    """Health grade from A (best) to F (worst)."""
    A = "excellent"
    B = "good"
    C = "acceptable"
    D = "concerning"
    F = "failing"


class RiskLevel(str, Enum):
    """Risk severity classification."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class LinkInfo(BaseModel):
    """Individual link data."""
    href: str
    anchor_text: str = ""
    is_internal: bool = True
    is_nofollow: bool = False
    context: str = ""

    class Config:
        frozen = True


class DensityMetrics(BaseModel):
    """Link density analysis results."""
    total_links: int = 0
    internal_links: int = 0
    external_links: int = 0
    nofollow_links: int = 0
    word_count: int = 0
    links_per_100_words: float = 0.0
    external_ratio: float = 0.0
    is_compliant: bool = True
    issues: list[str] = Field(default_factory=list)

    @property
    def density_score(self) -> float:
        """Convert to 0-100 score."""
        if self.is_compliant:
            return 100.0
        penalty = len(self.issues) * 15
        return max(0, 100 - penalty)


class AnchorMetrics(BaseModel):
    """Anchor text analysis results."""
    total_anchors: int = 0
    unique_anchors: int = 0
    diversity_score: float = 1.0
    exact_match_ratio: float = 0.0
    branded_ratio: float = 0.0
    generic_ratio: float = 0.0
    risk_score: float = 0.0
    risk_level: RiskLevel = RiskLevel.LOW
    flagged_patterns: list[str] = Field(default_factory=list)

    @property
    def anchor_score(self) -> float:
        """Convert to 0-100 score."""
        return (1 - self.risk_score) * 100


class HealthReport(BaseModel):
    """Complete health analysis report."""
    id: str = Field(default_factory=lambda: str(uuid4())[:8])
    url: HttpUrl
    analyzed_at: datetime = Field(default_factory=datetime.utcnow)
    
    grade: HealthGrade = HealthGrade.C
    composite_score: float = Field(default=50.0, ge=0, le=100)
    
    density: DensityMetrics = Field(default_factory=DensityMetrics)
    anchors: AnchorMetrics = Field(default_factory=AnchorMetrics)
    
    all_links: list[LinkInfo] = Field(default_factory=list)
    issues: list[str] = Field(default_factory=list)
    recommendations: list[str] = Field(default_factory=list)

    def calculate_score(self) -> None:
        """Calculate composite score and grade."""
        density_weight = {{ module.config.get('density_weight', 0.4) }}
        anchor_weight = {{ module.config.get('anchor_weight', 0.6) }}
        
        self.composite_score = round(
            self.density.density_score * density_weight +
            self.anchors.anchor_score * anchor_weight,
            1
        )
        
        if self.composite_score >= 90:
            self.grade = HealthGrade.A
        elif self.composite_score >= 75:
            self.grade = HealthGrade.B
        elif self.composite_score >= 60:
            self.grade = HealthGrade.C
        elif self.composite_score >= 40:
            self.grade = HealthGrade.D
        else:
            self.grade = HealthGrade.F


class AnalysisRequest(BaseModel):
    """API request for analysis."""
    url: HttpUrl
    include_links: bool = False
    

class AnalysisResponse(BaseModel):
    """API response wrapper."""
    success: bool = True
    report: Optional[HealthReport] = None
    error: Optional[str] = None


class BatchRequest(BaseModel):
    """Batch analysis request."""
    urls: list[HttpUrl] = Field(..., max_items=100)
    

class BatchResponse(BaseModel):
    """Batch analysis response."""
    success: bool = True
    reports: list[HealthReport] = Field(default_factory=list)
    failed: list[str] = Field(default_factory=list)
```

---

## modules/feature.seo.link_health_analyzer/templates/density_service.py.j2

```jinja2
{# ═══════════════════════════════════════════════════════════════════════════════
   TEMPLATE: Density Analysis Service
═══════════════════════════════════════════════════════════════════════════════ #}
"""
Link Density Analysis Service.

Analyzes link distribution and density compliance.
"""
import re
from urllib.parse import urlparse

from bs4 import BeautifulSoup
import structlog

from .models import DensityMetrics, LinkInfo

logger = structlog.get_logger()

# Configuration from blueprint
MAX_LINKS_PER_100_WORDS = {{ module.config.get('density_threshold', 3.0) }}
MAX_EXTERNAL_RATIO = {{ module.config.get('max_external_ratio', 0.3) }}


class DensityAnalyzer:
    """Analyzes link density in HTML content."""
    
    def __init__(
        self,
        max_density: float = MAX_LINKS_PER_100_WORDS,
        max_external: float = MAX_EXTERNAL_RATIO,
    ):
        self.max_density = max_density
        self.max_external = max_external
    
    def analyze(self, html: str, page_url: str) -> tuple[DensityMetrics, list[LinkInfo]]:
        """
        Analyze link density in HTML.
        
        Args:
            html: Raw HTML content
            page_url: URL of the page
            
        Returns:
            Tuple of (metrics, links)
        """
        soup = BeautifulSoup(html, "lxml")
        page_domain = urlparse(page_url).netloc
        
        links = self._extract_links(soup, page_domain)
        word_count = self._count_words(soup)
        
        total = len(links)
        internal = sum(1 for l in links if l.is_internal)
        external = total - internal
        nofollow = sum(1 for l in links if l.is_nofollow)
        
        density = (total / word_count * 100) if word_count > 0 else 0
        ext_ratio = external / total if total > 0 else 0
        
        issues = []
        if density > self.max_density:
            issues.append(f"Density {density:.1f}/100 exceeds {self.max_density}")
        if ext_ratio > self.max_external:
            issues.append(f"External ratio {ext_ratio:.0%} exceeds {self.max_external:.0%}")
        
        metrics = DensityMetrics(
            total_links=total,
            internal_links=internal,
            external_links=external,
            nofollow_links=nofollow,
            word_count=word_count,
            links_per_100_words=round(density, 2),
            external_ratio=round(ext_ratio, 3),
            is_compliant=len(issues) == 0,
            issues=issues,
        )
        
        logger.info("density_analyzed", url=page_url, density=density, compliant=metrics.is_compliant)
        return metrics, links
    
    def _extract_links(self, soup: BeautifulSoup, page_domain: str) -> list[LinkInfo]:
        """Extract all links from HTML."""
        links = []
        for a in soup.find_all("a", href=True):
            href = a["href"]
            if href.startswith(("#", "javascript:", "mailto:")):
                continue
                
            parsed = urlparse(href)
            is_internal = not parsed.netloc or parsed.netloc == page_domain
            
            rel = a.get("rel", [])
            is_nofollow = "nofollow" in (rel if isinstance(rel, list) else rel.split())
            
            links.append(LinkInfo(
                href=href,
                anchor_text=a.get_text(strip=True),
                is_internal=is_internal,
                is_nofollow=is_nofollow,
            ))
        return links
    
    def _count_words(self, soup: BeautifulSoup) -> int:
        """Count visible words in HTML."""
        for tag in soup(["script", "style", "nav", "header", "footer"]):
            tag.decompose()
        text = soup.get_text(separator=" ", strip=True)
        return len(re.findall(r"\b\w+\b", text))
```

---

## modules/feature.seo.link_health_analyzer/templates/api_router.py.j2

```jinja2
{# ═══════════════════════════════════════════════════════════════════════════════
   TEMPLATE: Link Health API Routes
═══════════════════════════════════════════════════════════════════════════════ #}
"""
Link Health Analysis API Routes.

Endpoints:
- POST /analyze - Analyze single URL
- POST /batch - Analyze multiple URLs
- GET /history/{domain} - Get analysis history
"""
from fastapi import APIRouter, HTTPException, BackgroundTasks
import structlog

from .models import (
    AnalysisRequest, AnalysisResponse,
    BatchRequest, BatchResponse,
    HealthReport,
)
from .health_service import HealthAnalyzer
from ..store import AnalysisStore

logger = structlog.get_logger()

router = APIRouter(
    prefix="{{ module.config.get('mount_path', '/link-health') }}",
    tags=["link-health"],
)

analyzer = HealthAnalyzer()
store = AnalysisStore()


@router.post("/analyze", response_model=AnalysisResponse)
async def analyze_url(request: AnalysisRequest) -> AnalysisResponse:
    """
    Analyze link health for a single URL.
    
    Returns comprehensive report with:
    - Density metrics
    - Anchor text analysis
    - Composite health score
    - Actionable recommendations
    """
    try:
        report = await analyzer.analyze(request)
        await store.save(report)
        return AnalysisResponse(success=True, report=report)
    except Exception as e:
        logger.exception("analysis_failed", url=str(request.url))
        return AnalysisResponse(success=False, error=str(e))


@router.post("/batch", response_model=BatchResponse)
async def analyze_batch(
    request: BatchRequest,
    background_tasks: BackgroundTasks,
) -> BatchResponse:
    """
    Analyze multiple URLs.
    
    Processes up to 100 URLs in parallel.
    Failed URLs are listed separately.
    """
    import asyncio
    
    async def analyze_one(url):
        try:
            req = AnalysisRequest(url=url)
            return await analyzer.analyze(req)
        except Exception:
            return None
    
    tasks = [analyze_one(url) for url in request.urls]
    results = await asyncio.gather(*tasks)
    
    reports = []
    failed = []
    
    for url, result in zip(request.urls, results):
        if result:
            reports.append(result)
            background_tasks.add_task(store.save, result)
        else:
            failed.append(str(url))
    
    return BatchResponse(success=True, reports=reports, failed=failed)


@router.get("/history/{domain}")
async def get_history(domain: str, limit: int = 50) -> list[HealthReport]:
    """Get analysis history for a domain."""
    return await store.get_by_domain(domain, limit=limit)


@router.get("/health")
async def health_check():
    """Service health check."""
    return {"status": "healthy", "service": "link-health-analyzer"}
```

---

## pipelines/link_health_pipeline.yaml

```yaml
# ═══════════════════════════════════════════════════════════════════════════════
# APEX PIPELINE: Link Health Analysis
# ═══════════════════════════════════════════════════════════════════════════════

id: "link_health_analysis_pipeline"
version: "1.0.0"
description: "End-to-end link health analysis with quality gates"

triggers:
  - type: "http"
    config:
      endpoint: "/api/link-health/analyze"
      method: "POST"
  
  - type: "schedule"
    config:
      cron: "0 */6 * * *"
      batch_source: "tracked_domains"

nodes:
  - id: "fetch_content"
    type: "external"
    pattern: "EXECUTION"
    capability: "http_fetch"
    schema: "HTMLContent"
    module: null
    depends_on: []
    params:
      timeout: 30
      retries: 3
      user_agent: "ApexBot/1.0"

  - id: "analyze_density"
    type: "apex_task"
    pattern: "EXPANSION"
    capability: "analysis"
    schema: "DensityMetrics"
    module: "feature.seo.link_health_analyzer"
    depends_on: ["fetch_content"]
    params:
      threshold: 3.0

  - id: "analyze_anchors"
    type: "apex_task"
    pattern: "EXPANSION"
    capability: "analysis"
    schema: "AnchorMetrics"
    module: "feature.seo.link_health_analyzer"
    depends_on: ["fetch_content"]
    params:
      diversity_threshold: 0.7

  - id: "calculate_score"
    type: "apex_task"
    pattern: "COMPRESSION"
    capability: "aggregation"
    schema: "HealthReport"
    module: "feature.seo.link_health_analyzer"
    depends_on: ["analyze_density", "analyze_anchors"]
    params:
      density_weight: 0.4
      anchor_weight: 0.6

  - id: "generate_recommendations"
    type: "apex_task"
    pattern: "EXPANSION"
    capability: "creative_generation"
    schema: "Recommendations"
    module: "feature.seo.link_health_analyzer"
    depends_on: ["calculate_score"]
    params:
      max_recommendations: 5

  - id: "store_result"
    type: "external"
    pattern: "EXECUTION"
    capability: "persistence"
    schema: "StorageResult"
    module: "core.sqlite_store"
    depends_on: ["generate_recommendations"]
    params:
      table: "health_reports"

quality_gates:
  - node_id: "analyze_density"
    min_score: 0.8
    
  - node_id: "analyze_anchors"
    min_score: 0.8
    
  - node_id: "calculate_score"
    min_score: 0.9

error_policy:
  on_node_failure: "skip_downstream"
  on_quality_failure: "retry_once"
  max_retries: 2
  fallback_response:
    success: false
    error: "Analysis failed - please try again"
```

---

**Run with:** `python bootstrap.py --blueprint=config/link_health_blueprint.yaml`
